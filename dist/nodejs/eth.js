"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
exports.createProvider = exports.getBalance = exports.getProviderNetwork = exports.trx = exports.read = void 0;
var ethers_1 = require("ethers");
var JsonRpc;
(function (JsonRpc) {
    JsonRpc[JsonRpc["EthSendTransaction"] = 0] = "EthSendTransaction";
    JsonRpc[JsonRpc["EthCall"] = 1] = "EthCall";
    // NetVersion,
})(JsonRpc || (JsonRpc = {}));
/**
 * This is a generic method for invoking JSON RPC's `eth_call` or `eth_send`
 *     with ethers.js. This function supports the public `read` and `trx`
 *     methods in this module.
 *
 * @param {boolean} isWrite True for `eth_send` and false for `eth_call`.
 * @param {string} address The Ethereum address the transaction is directed to.
 * @param {string} method The smart contract member in which to invoke.
 * @param {any[]} [parameters] Parameters of the method to invoke.
 * @param {CallOptions} [options] Options to set for `eth_call`, optional ABI
 *     (as JSON object), and ethers.js method overrides. The ABI can be a string
 *     of the single intended method, an array of many methods, or a JSON object
 *     of the ABI generated by a Solidity compiler.
 *
 * @returns {Promise<any>} Return value of the invoked smart contract member
 *     or an error object if the call failed.
 */
function _ethJsonRpc(jsonRpcMethod, address, method, parameters, options) {
    if (parameters === void 0) { parameters = []; }
    if (options === void 0) { options = {}; }
    return new Promise(function (resolve, reject) {
        var provider = options._compoundProvider || createProvider(options);
        var overrides = {
            gasPrice: options.gasPrice,
            nonce: options.nonce,
            value: options.value,
            chainId: options.chainId,
            from: options.from,
            gasLimit: options.gasLimit
        };
        parameters.push(overrides);
        var contract;
        var abi;
        if (options.abi) {
            // Assumes `method` is a string of the member name
            // Assumes `abi` is a JSON object
            abi = options.abi;
            contract = new ethers_1.ethers.Contract(address, abi, provider);
        }
        else {
            // Assumes `method` is a string of the member definition
            abi = [method];
            contract = new ethers_1.ethers.Contract(address, abi, provider);
            method = Object.keys(contract.functions)[1];
        }
        if (jsonRpcMethod === JsonRpc.EthSendTransaction) {
            contract[method].apply(null, parameters).then(function (result) {
                resolve(result);
            })["catch"](function (error) {
                reject({
                    message: 'Error occurred during [eth_sendTransaction]. See {error}.',
                    error: error,
                    method: method,
                    parameters: parameters
                });
            });
        }
        else if (jsonRpcMethod === JsonRpc.EthCall) {
            contract.callStatic[method].apply(null, parameters).then(function (result) {
                resolve(result);
            })["catch"](function (error) {
                reject({
                    message: 'Error occurred during [eth_call]. See {error}.',
                    error: error,
                    method: method,
                    parameters: parameters
                });
            });
        }
    });
}
/**
 * This is a generic method for invoking JSON RPC's `eth_call` with ethers.js.
 *     Use this method to execute a smart contract's constant or non-constant
 *     member without using gas. This is a read-only method intended to read a
 *     value or test a transaction for valid parameters. It does not create a
 *     transaction on the block chain.
 *
 * @param {string} address The Ethereum address the transaction is directed to.
 * @param {string} method The smart contract member in which to invoke.
 * @param {any[]} [parameters] Parameters of the method to invoke.
 * @param {CallOptions} [options] Options to set for `eth_call`, optional ABI
 *     (as JSON object), and ethers.js method overrides. The ABI can be a string
 *     of the single intended method, an array of many methods, or a JSON object
 *     of the ABI generated by a Solidity compiler.
 *
 * @returns {any} Return value of the invoked smart contract member or an error
 *     object if the call failed.
 */
function read(address, method, parameters, options) {
    if (parameters === void 0) { parameters = []; }
    if (options === void 0) { options = {}; }
    return _ethJsonRpc(JsonRpc.EthCall, address, method, parameters, options);
}
exports.read = read;
/**
 * This is a generic method for invoking JSON RPC's `eth_sendTransaction` with
 *     ethers.js. Use this method to create a transaction that invokes a smart
 *     contract method. Returns an ethers.js `TransactionResponse` object.
 *
 * @param {string} address The Ethereum address the transaction is directed to.
 * @param {string} method The smart contract member in which to invoke.
 * @param {any[]} [parameters] Parameters of the method to invoke.
 * @param {CallOptions} [options] Options to set for `eth_sendTransaction`,
 *     (as JSON object), and ethers.js method overrides. The ABI can be a string
 *     optional ABI of the single intended method, an array of many methods, or
 *     a JSON object of the ABI generated by a Solidity compiler.
 *
 * @returns {any} Returns an ethers.js `TransactionResponse` object or an error
 *     object if the transaction failed.
 */
function trx(address, method, parameters, options) {
    if (parameters === void 0) { parameters = []; }
    if (options === void 0) { options = {}; }
    return _ethJsonRpc(JsonRpc.EthSendTransaction, address, method, parameters, options);
}
exports.trx = trx;
function getProviderNetwork(provider) {
    return __awaiter(this, void 0, void 0, function () {
        var networkId, network;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (provider._isSigner) {
                        provider = provider.provider;
                    }
                    if (!provider.send) return [3 /*break*/, 2];
                    return [4 /*yield*/, provider.send('net_version')];
                case 1:
                    networkId = _a.sent();
                    return [3 /*break*/, 3];
                case 2:
                    networkId = provider._network.chainId;
                    _a.label = 3;
                case 3:
                    networkId = isNaN(networkId) ? 0 : +networkId;
                    network = ethers_1.ethers.providers.getNetwork(networkId) || {};
                    return [2 /*return*/, {
                            id: networkId,
                            name: network.name === 'homestead' ? 'mainnet' : network.name
                        }];
            }
        });
    });
}
exports.getProviderNetwork = getProviderNetwork;
function getBalance(address, provider) {
    return __awaiter(this, void 0, void 0, function () {
        var providerInstance, url, balance;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (typeof provider === 'object' && provider._isSigner) {
                        provider = provider.provider;
                    }
                    providerInstance = createProvider({ provider: provider });
                    if (!providerInstance.send) {
                        url = providerInstance.providerConfigs[0].provider.connection.url;
                        providerInstance = new ethers_1.ethers.providers.JsonRpcProvider(url);
                    }
                    return [4 /*yield*/, providerInstance.send('eth_getBalance', [address, 'latest'])];
                case 1:
                    balance = _a.sent();
                    return [2 /*return*/, balance];
            }
        });
    });
}
exports.getBalance = getBalance;
function createProvider(options) {
    if (options === void 0) { options = {}; }
    var provider = options.provider || (options.network || 'mainnet');
    var isADefaultProvider = !!ethers_1.ethers.providers.getNetwork(provider.toString());
    // Create an ethers provider, web3's can sign
    if (isADefaultProvider) {
        provider = ethers_1.ethers.getDefaultProvider(provider);
    }
    else if (typeof provider === 'object') {
        provider = new ethers_1.ethers.providers.Web3Provider(provider).getSigner();
    }
    else {
        provider = new ethers_1.ethers.providers.JsonRpcProvider(provider);
    }
    // Add an explicit signer
    if (options.privateKey) {
        provider = new ethers_1.ethers.Wallet(options.privateKey, provider);
    }
    else if (options.mnemonic) {
        provider = new ethers_1.ethers.Wallet(ethers_1.ethers.Wallet.fromMnemonic(options.mnemonic), provider);
    }
    return provider;
}
exports.createProvider = createProvider;
//# sourceMappingURL=eth.js.map