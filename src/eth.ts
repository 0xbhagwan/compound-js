import { ethers } from 'ethers';
// import { request } from './util';

interface CallOptions {
  abi?: string | object[];
  provider?: string;
  network?: string;
  from?: number | string;
  gas?: number;
  gasPrice?: number;
  gasLimit?: number;
  value?: number | string;
  data?: number | string;
  chainId?: number;
  nonce?: number;
  // blockNumber?: string;
  // id?: number;
}

/**
 * This is a generic method for invoking JSON RPC's `eth_call` with ethers.js. 
 *     Use this method to execute a smart contract's constant or non-constant 
 *     member without using gas. This is a read-only method intended to read a 
 *     value or test a transaction for valid parameters. It does not create a 
 *     transaction on the block chain.
 *
 * @param {string} address The Ethereum address the transaction is directed to.
 * @param {string} method The smart contract member in which to invoke.
 * @param {any[]} [parameters] Parameters of the method to invoke.
 * @param {CallOptions} [options] Options to set for `eth_call`, optional ABI
 *     (as JSON object), and ethers.js method overrides. The ABI can be a string
 *     of the single intended method, an array of many methods, or a JSON object
 *     of the ABI generated by a Solidity compiler.
 *
 * @returns {any} Return value of the invoked smart contract member or an error 
 *     object if the call failed.
 */
export function read(
  address: string,
  method: string,
  parameters: any[] = [],
  options: CallOptions = {}
): Promise<any> {
  return new Promise<any>((resolve: Function, reject: Function) => {
    const network = options.network || 'mainnet';
    const provider = options.provider ?
      new ethers.providers.JsonRpcProvider(options.provider) :
      ethers.getDefaultProvider(network);
    const overrides = {
      gasPrice: options.gasPrice,
      nonce: options.nonce,
      value: options.value,
      chainId: options.chainId,
      from: options.from,
      gasLimit: options.gasLimit,
    };
    parameters.push(overrides);

    let contract;
    let abi: any;
    if (options.abi) {
      // Assumes `method` is a string of the member name
      // Assumes `abi` is a JSON object
      abi = options.abi;
      contract = new ethers.Contract(address, abi, provider);
    } else {
      // Assumes `method` is a string of the member definition
      abi = [ method ];
      contract = new ethers.Contract(address, abi, provider);
      method = Object.keys(contract.functions)[1];
    }

    contract.callStatic[method].apply(null, parameters).then((result) => {
      resolve(result);
    }).catch((error) => {
      reject(error);
    });
  });
}
